% !TEX encoding = UTF-8 Unicode
\documentclass{article}

\usepackage{amsmath,amssymb,amsfonts,amsthm}
\usepackage{hyperref}
\usepackage{color}
\usepackage{unicode}
\hypersetup{colorlinks}

\hyphenation{Berle-kamp}

%%%%%%%%%%%%%%%

\newcommand{\ff}[1]{\mathbb{F}_{#1}}
\newcommand{\fq}{\ff{q}}
\newcommand{\fqn}{\ff{q^n}}

\newcommand{\dd}{d}
\newcommand{\qq}{q}
\newcommand{\QQ}{Q}
\newcommand{\nn}{n}
\newcommand{\qn}{{\qq^\nn}}
\newcommand{\extfactfdegree}{k}
\newcommand{\extfactfsize}{\qq^{\nn \cdot \extfactfdegree}}

% if we define everything in terms of base field, extension field and
% extension field used in factorization
%
\newcommand{\basef}{\ff{\qq}}
\newcommand{\extf}{\ff{\qn}}
\newcommand{\extfactf}{\ff{\extfactfsize}}

\newcommand{\AG}{\mathrm{AG}(\qq,\nn)}

\DeclareMathOperator{\Tr}{Tr}
\DeclareMathOperator{\Ker}{Ker}
\DeclareMathOperator{\Ima}{Im} 
\DeclareMathOperator{\Decomp}{Decomp} 
\DeclareMathOperator{\Var}{Var} 
\DeclareMathOperator{\Exp}{E} 
\DeclareMathOperator{\loglog}{loglog}


% to specify the number of elements of the finite fields on which the
% trace is defined
\newcommand{\tr}[2]{\Tr_{\ff{#1}:\ff{#2}}}

% to specify the number of elements of the finite fields on which the
% trace is defined: light form
\newcommand{\trl}[2]{\Tr_{#1:#2}}

% to specify the notation of the finite fields on which the trace is
% defined
\newcommand{\trabs}[2]{\Tr_{#1:#2}}
\newcommand{\trextbase}{\trabs{\extf}{\basef}}
\newcommand{\trextfactext}{\trabs{\extfactf}{\extf}}
\newcommand{\trextfactbase}{\trabs{\extfactf}{\basef}}

\newcommand{\bigO}{O}
\newcommand{\bigOt}{\tilde{O}}
\newcommand{\smallO}{o}
\newcommand{\Mul}{\mathsf{M}}

\newcommand{\Span}{\mathbf{span}}
\newcommand{\card}[1]{\# #1}
\DeclareMathOperator{\Res}{Res}

\newcommand{\cost}[1]{\color{blue}Cost:  #1\color{black}}

%%%%%%%%%%%% Algorithms

\usepackage{float,algorithm}
\usepackage[noend]{algorithmic}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\newcounter{algo}

\newenvironment{algorithm_noendline}[4]{\begin{center}\begin{minipage}{0.48\textwidth}
      \refstepcounter{algo}
      \label{#4}
      \sf
      \rule{\textwidth}{0.2pt}\\
      \makebox[\textwidth][c]{Algorithm~\arabic{algo}:~\textbf{#1}}\\
      \rule[0.5\baselineskip]{\textwidth}{0.2pt}\\

      \vspace{-12pt}

      \parbox{\textwidth}{\textbf{Input} #2}
      \parbox{\textwidth}{\textbf{Output} #3}

\vspace{-7pt}

      \begin{enumerate*}}{\end{enumerate*}
      \vspace{-11pt}
\end{minipage}\end{center}
}

\newenvironment{algorithm_endline}[4]{\begin{center}\begin{minipage}{0.48\textwidth}
      \refstepcounter{algo}
      \label{#4}
      \sf
      \rule{\textwidth}{0.2pt}\\
      \makebox[\textwidth][c]{Algorithm~\arabic{algo}:~\textbf{#1}}\\
      \rule[0.5\baselineskip]{\textwidth}{0.2pt}\\

      \vspace{-12pt}

      \parbox{\textwidth}{\textbf{Input} #2}
      \parbox{\textwidth}{\textbf{Output} #3}

\vspace{-7pt}

      \begin{enumerate*}}{\end{enumerate*}
      \vspace{-11pt}
      \rule{\textwidth}{0.2pt}
\end{minipage}\end{center}
%\vspace{-0.5cm}
}

\floatstyle{plain}
\newfloat{algofloat}{thp}{bla}
\floatname{algofloat}{}

%%%%%%%%%%

\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}
\newcommand{\com }{\noindent \textcolor{blue}{Commentaire Micha\"el}:}
\newcommand{\comd}{\noindent \textcolor{blue}{D\'ebut Micha\"el}:}
\newcommand{\comf}{\noindent \textcolor{blue}{:Fin Micha\"el}}




\newtheorem{Def}{Definition}
\newtheorem{Theo}{Theorem}
\newtheorem{Prop}{Proposition}
\newtheorem{Lem}{Lemma}
\newtheorem{Coro}{Corollary}


\newcommand{\Notes}[1]{\textcolor{red}{Note: #1}}

\author{Luca De Feo, Christophe Petit, Micha\"el Quisquater}

\title{On root finding algorithms in finite fields}

\begin{document}

\maketitle
\begin{abstract}
  We find roots
\end{abstract}


\Notes{
Decisions to be made:
\begin{itemize}
\item notations $n$, $d$, $q$, $Q=q^n$ then $Q_i$ for subfields
\item complexity model: bit vs field operations -> we will keep small field operations complexity
\item worst case vs average case -> both of them for deterministic algorithms
\item notation O tilde -> precise analysis, then simplified with O tilde
\item q is not O(1)
\end{itemize}
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{sec:introduction}

Let $\ff{q}$ be a finite field with $q$ elements, and let $f$ be a
polynomial of degree $d$ over $\ff{q}$.
%
The \emph{root-finding problem} is the problem of computing one,
several or all elements $x∈\ff{q}$ such that $f(x)=0$.
%
This problem has many applications, in particular in cryptography and
in coding theory~\cite{McEliece78} \Notes{either put more references,
  or less!}. It also has a rich history, with many strategies proposed
over the years. In this paper we review several algorithms for root
finding, and present a few new ones.  We highlight the relationships
between these algorithms by classifying them according to general
algorithmic principles, and using this classification to discover new
ones. We also present, when relevant, variants of the algorithms with
interesting properties. Finally, we implement most of the algorithms,
and compare their performances.

\subsection{A brief history of root finding}
\label{sec:brief-history-root}

As mentioned by von zur Gathen~\cite{Gathen06}, the first method for
finding the roots of $f∈\ff{q}[X]$, with $q$ an odd prime,
is due to Legendre (1752-1833) who starts by considering the
factorization of the field equation
$$X^q-X=X · (X^{(q-1)/2}-1) · (X^{(q-1)/2}+1).$$
He then observes that computing the GCD of $f$ with each of the two
latter factors splits the (nonzero) roots of $f$ into two sets, the
quadratic residues and the non-residues. Then, replacing $X$ by $X+r$
for a random $r$, yields other ways of splitting the roots into two
sets, which may recursively be applied on the factors of $f$. This
probabilistic method is the basis of many modern ones.

For a polynomial $f∈\ff{q}[X]$, with $q$ a prime power, the
factoring method of Berlekamp~\cite{berl67} is based on the so-called
\emph{Petr-Berlekamp algebra} of $f$ which consists of the set of
polynomials $h$ satisfying
$$h(X)^q=h(X) \mod{f(X)}.$$
Using $X^{q}-X=\prod_{r∈\ff{q}}(X-r)$, Berlekamp deduces the
factorization $f(X)=\prod_{r ∈ \ff{q}} \gcd(f(X),h(X)-r)$ \Notes{not
  clear to me}. The method requires to compute $q$ GCD's, hence it
cannot be used for arbitrary finite fields. The root-finding method
called \emph{Berlekamp Trace Algorithm} (BTA)~\cite{berl70} takes
advantage of the factorization
$$X^{q^n}-X=α^{-1} · \prod_{r ∈ \ff{q}}(\Tr_{\ff{q^n}/\ff{q}}(α · X)-r).$$
The roots of $f$ are separated by computing GCD's with the different
factors for varying $α$. This method is recursive, and it may be
applied to large finite fields with small characteristic. It is still
one of the most efficient methods today.

Moenck~\cite{Moenck77} used resultants to determine the $α$'s and
$r$'s leading to non-trivial GCD's in the above methods. He also
introduced the \emph{Subgroup Refinement Algorithm} to pursue further
the factorization of the field equation considered by Legendre by
considering successive subgroups of $\ff{q}^\ast$ for some
special primes $q$.  Rabin~\cite{Rabin79} proposed a method close to
Legendre's. \Notes{talk about Mignotte-Schnorr}

Cantor and Zassenhaus~\cite{cantor1981} suggested to consider random
polynomials $h(X)$ instead of $X+r$ in Legendre's decomposition in
order to factor a polynomial $f$ with factors of equal degree by means
of GCD's. The method is probabilistic and is one the most efficient
methods today.

Berlekamp~\cite{mBER84a} proposed the \emph{Least Affine Multiple
  method} (LAM) which consists in computing the least affine multiple
of $f$, then exhaustively searching the roots of $f$ among the roots
of this polynomial.

Menezes, van Oorschot and Vanstone~\cite{MenezesOV88,OorschotV89}
combined BTA with the LAM method. Moreover, they~\cite{Menvanovans92}
generalized Moenck's Subgroup Refinement Algorithm~\cite{Moenck77} and
introduced the \emph{Affine Refinement Method} (ARM) by mirroring the
successive refinement of a subgroup of $\ff{q}^\ast$ in Moenck's
algorithm by refinement of linear subspaces of $\AG$, the
$n$-dimensional affine geometry of $\ff{q}$.  As described in their
papers, the ARM makes use of the LAM method.

Shoup~\cite{Shoup91b} proposed a deterministic generalization of BTA
for the factorization and root-finding problems. Its worst-case
running time complexity is similar to the average running time of the
best known probabilistic methods such as BTA and Cantor-Zassenhaus.

Niederreiter~\cite{nied94} proposed an algorithm based on the
resolution of differential equations over finite fields.  As mentioned
by several authors~\cite{Fleis96} this algorithm is highly related
Berlekamp's factoring algorithm.

Recently, Petit~\cite{cgUCL-P14} introduced a method related to BTA
called the \emph{Successive Resultants Algorithm} (SRA), suitable for
fields $\ff{q^n}$ with small $q$. Later, Grenet, van der Hoeven and
Lecerf~\cite{grenet-hoeven-lecerf-roots,grenet2015deterministic}
suggested methods based on Graeffe transforms, adapted for \emph{FFT
  fields}, i.e., fields $\ff{q}$ where $q-1$ has a large $2$-adic
valuation. We call these methods \emph{Graeffe Transform Algorithms}
(GTA). SRA and GTA are similar in that they use resultants to reduce
the root finding problem to one in a smaller space, however are based
on different mathematical structures, as we shall see in the next
section.


\paragraph{Our contribution}
We give a unified presentation of several of the algorithms above. We
categorize them in two main families: \emph{additive algorithms} based
on the structure of the affine geometry $\AG$, and
\emph{multiplicative algorithms} based on the structure of the
multiplicative group $\ff{q}^\ast$.  We also highlight how SRM and GTA
are the multiplicative counterparts of BTA, ARM and SRA.  Finally, we
analyze the randomized versions of those algorithms when relevant.
Although most relationship between these algorithms have been folklore
for very long, to the best of our knowledge this is the first
systematic treatment of the kind. As a bonus, our classification
enabled us to discover a new algorithm derived from SRA.

Next, we present new variants of these algorithms exhibiting
interesting properties. In particular we provide \emph{hybrid}
algorithms which mix both the additive and the multiplicative
paradigms, retaining the benefits of both. \Notes{We also present
  variants of SOMETHING which improve SOMETHING}

Finally, we discuss non-trivial implementation details, and provide an
implementation of each of the algorithms analyzed in the paper. As far
as we know, this is the only comprehensive implementation covering so
many different root finding algorithms. We use our implementation to
compare the performances of the algorithms in various settings.


\subsection{Notation and complexity model}
\label{sec:compl-model-fund}

In the rest of the paper, $q$ is a prime or prime power, $n$ is an
integer $≥1$, we let $Q=q^n$, and we let $\ff{q},\ff{Q}$ be finite
fields with $q,Q$ elements respectively.  We also let $f$ be a
separable polynomial in $\ff{Q}[X]$ of degree $d$ which splits
completely in $\ff{Q}$. We measure all complexities in the algebraic
complexity model, where the cost of an algorithm is counted in terms
of the number of operations $(+,\times,\div)$ in $\ff{q}$. We use the
Landau notation $O(\ )$ to express asymptotic complexities, and the
notation $\bigOt(\ )$ to neglect logarithmic factors.

We let $\Mul_q(n)$ be the cost of multiplying two polynomials in
$\ff{q}[Z]$ of degree at most $n$, under the assumptions
of~\cite[Chapter~8.3]{Gathen2003}. When $q$ is clear from the context,
we simply write $\Mul(n)$.  Using FFT multiplication, one can take
$\Mul(n)∈ O(n\log(n)\loglog(n))$.  With this notation, elements of
$\ff{Q}$ can be multiplied in $O(\Mul_q(n))$ operations, and their
inverses in $O(\Mul_q(n)\log n)$ operations.

We also let $M_Q(d)$ be the cost of multiplying two polynomials in
$\ff{Q}[X]$ of degree at most $d$.  Using Kronecker's
substitution~\cite{moenck76,kaltofen87,Gathen2003,GathenS92,harvey09},
this can be done in $O(\Mul_q(dn))$ operations. Euclidean divisions of
degree at most $d$ in $\ff{Q}[X]$ and multiplications in the ring
$\ff{Q}[X]/f(X)$ also cost $O(\Mul_q(dn))$ operations. Finally
computing the GCD of two polynomials of degree at most $d$ costs
$O(\Mul_q(dn)\log(dn))$ operations
(see~\cite[Th.~11.5]{Gathen2003}).

We shall need to evaluate and interpolate polynomials of degree $d$ at
$O(d)$ points of $\ff{Q}$. Using the asymptotically fast algorithms
for evaluation and interpolation in~\cite[Chapter~10]{Gathen2003},
both operations can be performed in $O(\Mul_q(dn)\log d)$
operations.  In Section~\ref{sec:impl-exper-results} we will present
variants of these algorithms for special instances of the problem.

Finally, we let $ω$ be the \emph{exponent of linear algebra}, i.e., a
constant such that $n\times n$ matrices with coefficients in any field
$k$ can be multiplied using $O(n^\omega)$ additions and
multiplications in $n$.


\paragraph{Outline}
The paper is organized as follows. In
Section~\ref{sec:root-find-algor} we give a systematic presentation of
the different root finding algorithms. Then, in
Section~\ref{sec:new-variants} we present variants of the previous
algorithms with interesting properties. Finally, in
Section~\ref{sec:impl-exper-results} present our implementation and
experimental results.




\section{Root-finding algorithms and their relationships}
\label{sec:root-find-algor}



\begin{itemize}
\item Introduction
\item High level view of main principles and links between the
  algorithms:
  \begin{itemize}
  \item Affine geometry;
  \item Multiplicative structure;
  \item Duality: GCD vs resultant;
  \item Randomization;
  \end{itemize}
\item Comparative chart of algorithms
\end{itemize}


\subsection{Additive algorithms}
\label{sec:affine-geom-algor}
\Notes{Some bits from beginning of Section 3 in Christophe's document, to be split between here and  intro of Section 2}

\medskip 

We now present three root finding algorithms based on the structure of $\AG$. Our presentation will not necessarily follow the original ones and algorithmic change will be explicitly mentionned. 
This first method is called Berlekamp's trace algorithm (BTA)~\cite{berl70} and was designed in the seventies. The second one was developped by Menezes, van Oorschot and Vanstone~\cite{Menvanovans92}
 twenty years later and is called Affine Refinement Method (ARM). The third method was recently 
 proposed by Petit and is called the Successive Resultants Algorithm (SRA) of Petit~\cite{cgUCL-P14}. In order to present these methods we need to introduce some basic concepts of affine geometry.

\paragraph{Affine geometry of $\AG$.} The \emph{finite affine geometry} $\AG$ is the set of all vector subspaces of $\basef^\nn$ and their translates. Fixing a basis $\{\upsilon_1,\ldots,\upsilon_\nn\}$ of $\extf$ over $\basef$, we can
identify the elements of $\extf$ with the points of $\AG$. To this basis, we associate the flag of linear
subspaces $V_0\subset V_1\subset \cdots \subset V_\nn$ defined by
\begin{equation}
  V_i = \Span(\upsilon_1,\dots,\upsilon_i),
\end{equation}
so that $\dim V_i = i$ and $\card V_i = \qq^i$.

Let now $\rho\in\extf$, such that $\rho=\sum_j r_j\upsilon_j$.  For any
$V_i$ we define the affine space (also called an $i$-flat)
\begin{equation}
  V_{i,\rho} = V_i + \rho.
\end{equation}
By construction, the reunion of all $i$-flats for any $i$ is
isomorphic to $\AG$, and we call it the \emph{affine geometry of
  $\extf$}.
Observe that $V_{i,\rho}=V_{i,\rho'}$, if and only if $\rho-\rho'\in V_i$. Hence
any $V_{i,\rho}$ can be represented canonically by taking $\rho$ of
the form $\rho=\sum_{j>i}r_j\upsilon_j$. There are exactly
$\qq^{n-i}$ distinct $i$-flats, each of size $\qq^i$. By definition we have
\begin{equation}
  V_{i,\rho} = \bigcup_{r_i \in\basef} V_{i-1,\rho + r_i \upsilon_i},
\end{equation}
where $\rho$ may be canonically chosen as $\sum_{j>i}r_j\upsilon_j$.

\medskip

\noindent All the three root finding methods are based on a recursive decomposition of $\extf$ into $i$-flats 
according the above rule. This decomposition leads to a $\qq$-ary tree where the root 
is $V_{n}=\extf$ and each leaf is in one-to-one correspondence with an element of $\extf$.

\medskip

\paragraph{Principle of BTA, ARM and SRA methods.} Consider a polynomial $f$ of degree $\dd$ over $\extf$. In BTA and ARM methods, the roots of $f$ are determined by recursively separating the roots of $f$ contained in $V_{i,\rho}$ into sets of roots contained in the different children of $V_{i,\rho}$. These methods consist in intersecting sets which is pratically achieved by computing GCD's between minimal polynomials representing these sets. From this proceduce the roots of $f$ may be deduced because 
theses sets will ultimately contain one element whose (monic) minimal polynomials are linear with the element as a constant term. In BTA method minimal polynomials representing the children of $V_{i,\rho}$ 
are expressed as a GCD of hyperplanes while in ARM method they are explicitly computed at each stage.

\medskip
 
SRA method consists in recursively identifying the children of $V_{i,\rho}$ containing roots of $f$. 
This can be pratically achieved by determining among the minimal polynomials of the children of 
$V_{i,\rho}$ the ones having a zero resultant with $f$. %This method consists therefore in projecting the roots of $f$ onto the space $V_{i-1}^\ast$.
From this proceduce the roots of $f$ may be deduced because the method ultimately determines the leafs containing a root of $f$ which are sets containing a single element.



In order to implement the above general principles practically we need to introduce some 
mathematical tools.

%\subsubsection{Algebraic objects related to the affine geometry AG(\qq,\nn)}
%\label{sec:affine-geom}

\paragraph{Algebraic objects related to BTA, ARM and SRA}

To each of the subspaces $V_i$ we associate its minimal polynomial, that we denote by
$L_i$. The polynomials $L_i$ satisfy a recurrence relation 
\begin{equation}
\label{Li_generation}
  L_0(X) = X, \; \;  L_i(X) = (X^\qq - L_{i-1}(\upsilon_i)^{\qq-1}X)\circ L_{i-1}(X)
\end{equation}
(see~\cite[Ch. 11]{mBER84a}). In particular $L_\nn(X)=X^\qn-X$. Notice that, by definition, each $L_i$ defines a linear map
$\extf\to\extf$, with kernel $V_i$. It will be convenient to encode
this information in an $\nn\times\nn$ matrix. We define
$\gamma_{i,j}:=L_i(\upsilon_j)$, and
\begin{equation}
  \label{eq:Gamma}
  \Gamma :=
  \begin{pmatrix}
    \gamma_{0,1} & \cdots & \gamma_{0,\nn}\\
    \vdots & & \vdots\\
    \gamma_{\nn-1,1} & \cdots & \gamma_{\nn-1,\nn}
  \end{pmatrix}.
\end{equation}
Observe that by definition $\gamma_{i,j}=0$ whenever $j\le i$, hence
$\Gamma$ is an upper triangular matrix, associated to a linear map
$\extf\to\extf^\nn$ sending any $\delta\in\extf$ to the vector
$\bigl(L_0(\delta),\dots,\allowbreak L_{n-1}(\delta)\bigr)$.  The diagonal elements of $\Gamma$ play a special role in our algorithms.
We define $\beta_i:=\gamma_{i-1,i}$ and $\alpha_i:=\beta_i^{\qq-1}$
for any $1\le i \le \nn$. We deduce a decomposition
\begin{equation}
\label{decomposition_field_eq_gen}
  X^\qn - X = (X^\qq - \alpha_\nn X) \circ \cdots \circ (X^\qq - \alpha_1 X).
\end{equation}
\Notes{I would not speak about dual space, just define $V_i^\ast$}
We define $V_i^\ast$ as the image space of $L_i$, i.e., the subspace
generated by the elements of the $i$-th row of $\Gamma$.  It is easily verified that
$\dim V_i^\ast=n-i$ and that $\{\gamma_{i,i+1},\dots,\gamma_{i,\nn}\}$
is a basis of $V_i^\ast$. Let $L_i^\ast$ be the minimal polynomial of
$V_i^\ast$. It is shown in~\cite[Ch. 11]{mBER84a} that
$L_i^\ast$ is the unique linearized polynomial such that
\begin{equation}
\label{dual_polynomial}
(L_i^\ast \circ L_i)(X)=(L_i \circ L_i^\ast)(X)=X^\qn-X\,,
\end{equation}
where $L_i^\ast$ is called the \emph{dual} of $L_i$.

\medskip

Another important linear map is the trace application over $\extf$ relative to $\basef$ defined by $\Tr_{\extf/\basef}(X)=\sum_{i=0}^{n-1} X^{\qq^i}$. Its kernel is a subspace of $\extf$ with dimension $n-1$. For any basis $\{\upsilon_1,\ldots,\upsilon_\nn\}$ of $\extf$ over $\basef$, there exists a \emph{dual basis} $\{\beta_1,\ldots,\beta_\nn\}$ satisfying  
$$
\Tr_{\extf/\basef}(\upsilon_i \cdot \beta_j)=
\left\{
\begin{array}{ll}
1 & \mbox{if } i=j, \\
0 &  \mbox{otherwise}. \\
\end{array}
\right.
$$
%\paragraph{The affine geometry of $\extf$} 
Finally, we define the polynomial $M_{i,\rho}$ as the minimal
polynomial of $V_{i,\rho}$, hence
\begin{equation}
  M_{i,\rho}(X) = L_i(X - \rho) = L_i(X) - \sum_{j>i}r_j\gamma_{i,j}.
\end{equation}
%$V_{i,\rho}=V_{i,\rho'}$
Similarly to the $i$-flats $V_{i,\rho}$, we observe that $M_{i,\rho}=M_{i,\rho'}$ if and only if $\rho-\rho'\in V_i$. Hence
any $M_{i,\rho}$ can be represented canonically by taking $\rho$ of
the form $\rho=\sum_{j>i}r_j\upsilon_j$. According to the decomposition rule~(\ref{decomposition-tree-iflats}) concerning the $i$-flats $V_{i,\rho}$, we have
\begin{equation}
\label{node_product}
  M_{i,\rho}(X) = \prod_{c\in\basef} M_{i-1,\rho+c\upsilon_i}(X).
\end{equation}
This defines a decomposition of $X^{\qn}-X$ into a product tree, where
each node at level $i$ is a $M_{i,\rho}$, defined by a
$\rho=\sum_{j>n-i}r_j\upsilon_j$, and has $\qq$ children, defined by
the elements $c\upsilon_{n-i}+\rho$ for $c\in\basef$. In particular,
the leaves are the linear polynomials $X-\rho$ for all points
$\rho\in\extf$.
%
Note that the product tree depends on the basis $\{\upsilon_1,\ldots,\upsilon_\nn\}$ and is isomorphic to the $q$-ary defined in terms of $i$-flats $V_{i,\rho}$.











\subsubsection{Berlekamp's Trace Algorithm}
\label{sec:BTA}
\Notes{Start from Section 3.1 in Christophe's document; MQ wants additional links with set intersections}

\subsubsection{Affine Refinement Method}
\label{sec:ARN}
\Notes{Start mainly from Section 3.2 in ISSAC, maybe a bit from Section 3.2 in Christophe}


\subsubsection{The Successive Resultants Algorithm}
\label{sec:SRA}
\Notes{Start from either Section 3.3 in Christophe's document or ISSAC 3.2, but be careful to keep parallelism with ARM}


\subsubsection{BTRA}
\Notes{See whether we have something competitive and worth mentioning; mention link with Moenck}


\subsection{Multiplicative algorithms}
\label{sec:mult-algor}
\Notes{Discuss parallelisms with Section~\ref{sec:affine-geom-algor}}\\
\noindent\Notes{Maybe move first two paragraphs of Section 4.1 in Christophe's document}

\subsubsection{Moenck's algorithm}
\label{sec:Moenck}
\Notes{Section 4.1 in Christophe's document, maybe move first two paragraphs to intro of Section~\ref{sec:mult-algor}}\\
\noindent \Notes{Careful: the extension described was already done by MOV}\\
\noindent\Notes{+ Mignotte-Schnorr ?}

\subsubsection{Successive Resultants approach}
\label{sec:LIX}
\Notes{Rewrite Section 4.2 in Christophe's document to enhance links with LIX deterministic (not real algorithm)}



\subsection{Randomized variants}
\label{sec:randomized-variants}

\Notes{Some intro}

\subsection{Legendre}
\label{sec:legendre}

\subsection{Randomized BTA}
\label{sec:BTArand}

\subsection{Randomized BTRA}
\label{sec:BTRArand}
\Notes{??}

\subsection{LIX algorithm}
\label{sec:LIXrand}

\subsection{Randomized SRA}
\label{sec:SRArand}




\section{New algorithm variants}
\label{sec:new-variants}

\subsection{Hybrid algorithms}
\label{sec:hybrid-algorithms}

\subsubsection{ARM-Moenck hybrid}
\subsubsection{SRA-LIX hybrid}
\Notes{??}



\subsection{SRA and ARM with improved worst case complexity}
\label{sec:worst-case}


\subsection{ARM variant with low precomputation}
\label{sec:low-precomputation}


\subsection{Composite degree extensions}
\label{sec:composite-degree}


\subsection{Coset intersection variant of Moenck}
\label{sec:SRAMoenck}
\Notes{Section 4.3 in Christophe's document. Remove?}



\section{Implementation and experimental results}
\label{sec:impl-exper-results}

\begin{itemize}
\item $\gamma_{ij}$ precomputation
\item faster resultant
\end{itemize}

\section{Conclusion}
\label{sec:conclusion}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliography{refs}
\bibliographystyle{alpha}

\end{document}



% Local Variables:
% ispell-local-dictionary:"american"
% End:


%  LocalWords:  affine subspaces linearized factorizations
%  LocalWords:  iteratively
