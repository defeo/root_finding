% !TEX encoding = UTF-8 Unicode
\documentclass{article}

\usepackage{amsmath,amssymb,amsfonts,amsmath}
\usepackage{hyperref}
\usepackage{color}


\hyphenation{Berle-kamp}

%%%%%%%%%%%%%%%

\newcommand{\ff}[1]{\mathbb{F}_{#1}}
\newcommand{\fq}{\ff{q}}
\newcommand{\fqn}{\ff{q^n}}

\newcommand{\dd}{d}
\newcommand{\qq}{q}
\newcommand{\QQ}{Q}
\newcommand{\nn}{n}
\newcommand{\qn}{{\qq^\nn}}
\newcommand{\extfactfdegree}{k}
\newcommand{\extfactfsize}{\qq^{\nn \cdot \extfactfdegree}}

% if we define everything in terms of base field, extension field and
% extension field used in factorization
%
\newcommand{\basef}{\ff{\qq}}
\newcommand{\extf}{\ff{\qn}}
\newcommand{\extfactf}{\ff{\extfactfsize}}

\newcommand{\AG}{\mathrm{AG}(\qq,\nn)}

\DeclareMathOperator{\Tr}{Tr}
\DeclareMathOperator{\Ker}{Ker}
\DeclareMathOperator{\Ima}{Im} 
\DeclareMathOperator{\Decomp}{Decomp} 
\DeclareMathOperator{\Var}{Var} 
\DeclareMathOperator{\Exp}{E} 
\DeclareMathOperator{\loglog}{loglog}


% to specify the number of elements of the finite fields on which the
% trace is defined
\newcommand{\tr}[2]{\Tr_{\ff{#1}:\ff{#2}}}

% to specify the number of elements of the finite fields on which the
% trace is defined: light form
\newcommand{\trl}[2]{\Tr_{#1:#2}}

% to specify the notation of the finite fields on which the trace is
% defined
\newcommand{\trabs}[2]{\Tr_{#1:#2}}
\newcommand{\trextbase}{\trabs{\extf}{\basef}}
\newcommand{\trextfactext}{\trabs{\extfactf}{\extf}}
\newcommand{\trextfactbase}{\trabs{\extfactf}{\basef}}

\newcommand{\bigO}{O}
\newcommand{\bigOt}{\tilde{O}}
\newcommand{\smallO}{o}
\newcommand{\Mul}{\mathsf{M}}

\newcommand{\Span}{\mathbf{span}}
\newcommand{\card}[1]{\# #1}
\DeclareMathOperator{\Res}{Res}

\newcommand{\cost}[1]{\color{blue}Cost:  #1\color{black}}

%%%%%%%%%%%% Algorithms

\usepackage{float,algorithm}
\usepackage[noend]{algorithmic}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\newcounter{algo}

\newenvironment{algorithm_noendline}[4]{\begin{center}\begin{minipage}{0.48\textwidth}
      \refstepcounter{algo}
      \label{#4}
      \sf
      \rule{\textwidth}{0.2pt}\\
      \makebox[\textwidth][c]{Algorithm~\arabic{algo}:~\textbf{#1}}\\
      \rule[0.5\baselineskip]{\textwidth}{0.2pt}\\

      \vspace{-12pt}

      \parbox{\textwidth}{\textbf{Input} #2}
      \parbox{\textwidth}{\textbf{Output} #3}

\vspace{-7pt}

      \begin{enumerate*}}{\end{enumerate*}
      \vspace{-11pt}
\end{minipage}\end{center}
}

\newenvironment{algorithm_endline}[4]{\begin{center}\begin{minipage}{0.48\textwidth}
      \refstepcounter{algo}
      \label{#4}
      \sf
      \rule{\textwidth}{0.2pt}\\
      \makebox[\textwidth][c]{Algorithm~\arabic{algo}:~\textbf{#1}}\\
      \rule[0.5\baselineskip]{\textwidth}{0.2pt}\\

      \vspace{-12pt}

      \parbox{\textwidth}{\textbf{Input} #2}
      \parbox{\textwidth}{\textbf{Output} #3}

\vspace{-7pt}

      \begin{enumerate*}}{\end{enumerate*}
      \vspace{-11pt}
      \rule{\textwidth}{0.2pt}
\end{minipage}\end{center}
%\vspace{-0.5cm}
}

\floatstyle{plain}
\newfloat{algofloat}{thp}{bla}
\floatname{algofloat}{}

%%%%%%%%%%

\newcommand{\todo}[1]{\textcolor{red}{TODO: #1}}
\newcommand{\com }{\noindent \textcolor{blue}{Commentaire Micha\"el}:}
\newcommand{\comd}{\noindent \textcolor{blue}{D\'ebut Micha\"el}:}
\newcommand{\comf}{\noindent \textcolor{blue}{:Fin Micha\"el}}




\newtheorem{Def}{Definition}
\newtheorem{Theo}{Theorem}
\newtheorem{Prop}{Proposition}
\newtheorem{Lem}{Lemma}
\newtheorem{Coro}{Corollary}


\newcommand{\Notes}[1]{\textcolor{red}{Note: #1}}

\author{Luca De Feo, Christophe Petit, Micha\"el Quisquater}

\title{On root finding algorithms in finite fields}

\begin{document}

\maketitle
\begin{abstract}
  We find roots
\end{abstract}


\Notes{
Decisions to be made:
\begin{itemize}
\item notations $n$, $d$, $q$, $Q=q^n$ then $Q_i$ for subfields
\item complexity model: bit vs field operations -> we will keep small field operations complexity
\item worst case vs average case -> both of them for deterministic algorithms
\item notation O tilde -> precise analysis, then simplified with O tilde
\item q is not O(1)
\end{itemize}
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{sec:introduction}

\begin{itemize}
\item Context, previous work;
\item Our contribution;
\item Technical prerequisites: basic routines, etc.
\end{itemize}




\section{Root-finding algorithms and their relationships}
\label{sec:root-find-algor}

\begin{itemize}
\item Introduction
\item High level view of main principles and links between the
  algorithms:
  \begin{itemize}
  \item Affine geometry;
  \item Multiplicative structure;
  \item Duality: GCD vs resultant;
  \item Randomization;
  \end{itemize}
\item Comparative chart of algorithms
\end{itemize}

\Notes{Some bits from beginning of Section 3 in Christophe's document, and beginning of Section 3.2 in ISSAC}

\subsection{Affine geometric algorithms}
\label{sec:affine-geom-algor}
\Notes{Some bits from beginning of Section 3 in Christophe's document, to be split between here and  intro of Section 2}
ATTENTION: il faut mentionner que $f$ est squarefree.

\medskip 

We now present three root finding algorithms based on the structure of $\AG$. Our presentation will not necessarily follow the original ones and algorithmic change will be explicitly mentionned. 
This first method is called Berlekamp's trace algorithm (BTA)~\cite{berl70} and was designed in the seventies. The second one was developped by Menezes, van Oorschot and Vanstone~\cite{Menvanovans92}
 twenty years later and is called Affine Refinement Method (ARM). The third method was recently 
 proposed by Petit and is called the Successive Resultants Algorithm (SRA) of Petit~\cite{cgUCL-P14}. In order to present these methods we need to introduce some basic concepts of affine geometry.

\paragraph{Affine geometry of $\AG$.} The \emph{finite affine geometry} $\AG$ is the set of all vector subspaces of $\basef^\nn$ and their translates. Fixing a basis $\{\upsilon_1,\ldots,\upsilon_\nn\}$ of $\extf$ over $\basef$, we can
identify the elements of $\extf$ with the points of $\AG$. To this basis, we associate the flag of linear
subspaces $V_0\subset V_1\subset \cdots \subset V_\nn$ defined by
\begin{equation}
  V_i = \Span(\upsilon_1,\dots,\upsilon_i),
\end{equation}
so that $\dim V_i = i$ and $\card V_i = \qq^i$.

Let now $\rho\in\extf$, such that $\rho=\sum_j r_j\upsilon_j$.  For any
$V_i$ we define the affine space (also called an $i$-flat)
\begin{equation}
  V_{i,\rho} = V_i + \rho.
\end{equation}
By construction, the reunion of all $i$-flats for any $i$ is
isomorphic to $\AG$, and we call it the \emph{affine geometry of
  $\extf$}.
Observe that $V_{i,\rho}=V_{i,\rho'}$, if and only if $\rho-\rho'\in V_i$. Hence
any $V_{i,\rho}$ can be represented canonically by taking $\rho$ of
the form $\rho=\sum_{j>i}r_j\upsilon_j$. There are exactly
$\qq^{n-i}$ distinct $i$-flats, each of size $\qq^i$. By definition we have
\begin{equation}
  V_{i,\rho} = \bigcup_{r_i \in\basef} V_{i-1,\rho + r_i \upsilon_i},
\end{equation}
where $\rho$ may be canonically chosen as $\sum_{j>i}r_j\upsilon_j$.

\medskip

\noindent All the three root finding methods are based on a recursive decomposition of $\extf$ into $i$-flats 
according the above rule. This decomposition leads to a $\qq$-ary tree where the root 
is $V_{n}=\extf$ and each leaf is in one-to-one correspondence with an element of $\extf$.

\medskip

\paragraph{Principle of BTA, ARM and SRA methods.} Consider a polynomial $f$ of degree $\dd$ over $\extf$. In BTA and ARM methods, the roots of $f$ are determined by recursively separating the roots of $f$ contained in $V_{i,\rho}$ into sets of roots contained in the different children of $V_{i,\rho}$. These methods consist in intersecting sets which is pratically achieved by computing GCD's between minimal polynomials representing these sets. From this proceduce the roots of $f$ may be deduced because 
theses sets will ultimately contain one element whose (monic) minimal polynomials are linear with the element as a constant term. In BTA method minimal polynomials representing the children of $V_{i,\rho}$ 
are expressed as a GCD of hyperplanes while in ARM method they are explicitly computed at each stage.

\medskip
 
SRA method consists in recursively identifying the children of $V_{i,\rho}$ containing roots of $f$. 
This can be pratically achieved by determining among the minimal polynomials of the children of 
$V_{i,\rho}$ the ones having a zero resultant with $f$. %This method consists therefore in projecting the roots of $f$ onto the space $V_{i-1}^\ast$.
From this proceduce the roots of $f$ may be deduced because the method ultimately determines the leafs containing a root of $f$ which are sets containing a single element.




\subsubsection{Algebraic object related to the affine geometry AG(\qq,\nn)}
\label{sec:affine-geom}


\Notes{Mic: dans cette section on explique commment on represente en pratique algebriquement les espaces. }

To each of the
subspaces we associate its minimal polynomial, that we denote by
$L_i$. The polynomials $L_i$ satisfy a recurrence relation 
\begin{equation}
\label{Li_generation}
  L_0(X) = X, \; \;  L_i(X) = (X^\qq - L_{i-1}(\upsilon_i)^{\qq-1}X)\circ L_{i-1}(X)
\end{equation}
(see~\cite[Ch. 11]{mBER84a}). In particular $L_\nn(X)=X^\qn-X$.

Notice that, by definition, each $L_i$ defines a linear map
$\extf\to\extf$, with kernel $V_i$. It will be convenient to encode
this information in an $\nn\times\nn$ matrix. We define
$\gamma_{i,j}:=L_i(\upsilon_j)$, and
\begin{equation}
  \label{eq:Gamma}
  \Gamma :=
  \begin{pmatrix}
    \gamma_{0,1} & \cdots & \gamma_{0,\nn}\\
    \vdots & & \vdots\\
    \gamma_{\nn-1,1} & \cdots & \gamma_{\nn-1,\nn}
  \end{pmatrix}.
\end{equation}
Observe that by definition $\gamma_{i,j}=0$ whenever $j\le i$, hence
$\Gamma$ is an upper triangular matrix, associated to a linear map
$\extf\to\extf^\nn$ sending any $\delta\in\extf$ to the vector
$\bigl(L_0(\delta),\dots,\allowbreak L_{n-1}(\delta)\bigr)$.  


The diagonal elements of $\Gamma$ play a special role in our algorithms.
We define $\beta_i:=\gamma_{i-1,i}$ and $\alpha_i:=\beta_i^{\qq-1}$
for any $1\le i \le \nn$. We deduce a decomposition
\begin{equation}
\label{decomposition_field_eq_gen}
  X^\qn - X = (X^\qq - \alpha_\nn X) \circ \cdots \circ (X^\qq - \alpha_1 X).
\end{equation}

\paragraph{The affine geometry of $\extf$} 
 We also define the polynomial $M_{i,\rho}$ as the minimal
polynomial of $V_{i,\rho}$, hence
\begin{equation}
  M_{i,\rho}(X) = L_i(X - \rho) = L_i(X) - \sum_{j>i}r_j\gamma_{i,j}.
\end{equation}
Observe that $M_{i,\rho}=M_{i,\rho'}$, and thus
$V_{i,\rho}=V_{i,\rho'}$, if and only if $\rho-\rho'\in V_i$. Hence
any $V_{i,\rho}$ can be represented canonically by taking $\rho$ of
the form $\rho=\sum_{j>i}r_j\upsilon_j$. There are exactly
$\qq^{n-i}$ distinct $i$-flats, each of size $\qq^i$.

By definition we have
\begin{equation}
  V_{i,\rho} = \bigcup_{c\in\basef} V_{i-1,\rho + c\upsilon_i},
\end{equation}
hence
\begin{equation}
\label{node_product}
  M_{i,\rho}(X) = \prod_{c\in\basef} M_{i-1,\rho+c\upsilon_i}(X).
\end{equation}
This defines a decomposition of $X^{\qn}-X$ into a product tree, where
each node at level $i$ is a $M_{i,\rho}$, defined by a
$\rho=\sum_{j>n-i}r_j\upsilon_j$, and has $\qq$ children, defined by
the elements $c\upsilon_{n-i}+\rho$ for $c\in\basef$. In particular,
the leaves are the linear polynomials $X-\rho$ for all points
$\rho\in\extf$.
%
Note that the product tree depends on the basis $\{\upsilon_1,\ldots,\upsilon_\nn\}$.


\paragraph{Dual spaces}
We define $V_i^\ast$ as the image space of $L_i$, i.e., the subspace
generated by the elements of the $i$-th row of $\Gamma$.  It is easily verified that
$\dim V_i^\ast=n-i$ and that $\{\gamma_{i,i+1},\dots,\gamma_{i,\nn}\}$
is a basis of $V_i^\ast$. Let $L_i^\ast$ be the minimal polynomial of
$V_i^\ast$. It is shown in~\cite[Ch. 11]{mBER84a} that
$L_i^\ast$ is the unique linearized polynomial such that
\begin{equation}
\label{dual_polynomial}
(L_i^\ast \circ L_i)(X)=(L_i \circ L_i^\ast)(X)=X^\qn-X\,,
\end{equation}
where $L_i^\ast$ is called the \emph{dual} of $L_i$.







\subsubsection{Berlekamp's Trace Algorithm}
\label{sec:BTA}
\Notes{Start from Section 3.1 in Christophe's document; MQ wants additional links with set intersections}

\subsubsection{Affine Refinement Method}
\label{sec:ARN}
\Notes{Start mainly from Section 3.2 in ISSAC, maybe a bit from Section 3.2 in Christophe}


\subsubsection{The Successive Resultants Algorithm}
\label{sec:SRA}
\Notes{Start from either Section 3.3 in Christophe's document or ISSAC 3.2, but be careful to keep parallelism with ARM}


\subsubsection{BTRA}
\Notes{See whether we have something competitive and worth mentioning; mention link with Moenck}


\subsection{Multiplicative algorithms}
\label{sec:mult-algor}
\Notes{Discuss parallelisms with Section~\ref{sec:affine-geom-algor}}\\
\noindent\Notes{Maybe move first two paragraphs of Section 4.1 in Christophe's document}

\subsubsection{Moenck's algorithm}
\label{sec:Moenck}
\Notes{Section 4.1 in Christophe's document, maybe move first two paragraphs to intro of Section~\ref{sec:mult-algor}}\\
\noindent \Notes{Careful: the extension described was already done by MOV}\\
\noindent\Notes{+ Mignotte-Schnorr ?}

\subsubsection{Successive Resultants approach}
\label{sec:LIX}
\Notes{Rewrite Section 4.2 in Christophe's document to enhance links with LIX deterministic (not real algorithm)}



\subsection{Randomized variants}
\label{sec:randomized-variants}

\Notes{Some intro}

\subsection{Legendre}
\label{sec:legendre}

\subsection{Randomized BTA}
\label{sec:BTArand}

\subsection{Randomized BTRA}
\label{sec:BTRArand}
\Notes{??}

\subsection{LIX algorithm}
\label{sec:LIXrand}

\subsection{Randomized SRA}
\label{sec:SRArand}




\section{New algorithm variants}
\label{sec:new-variants}

\subsection{Hybrid algorithms}
\label{sec:hybrid-algorithms}

\subsubsection{ARM-Moenck hybrid}
\subsubsection{SRA-LIX hybrid}
\Notes{??}



\subsection{SRA and ARM with improved worst case complexity}
\label{sec:worst-case}


\subsection{ARM variant with low precomputation}
\label{sec:low-precomputation}


\subsection{Composite degree extensions}
\label{sec:composite-degree}


\subsection{Coset intersection variant of Moenck}
\label{sec:SRAMoenck}
\Notes{Section 4.3 in Christophe's document. Remove?}



\section{Implementation and experimental results}
\label{sec:impl-exper-results}

\begin{itemize}
\item $\gamma_{ij}$ precomputation
\item faster resultant
\end{itemize}

\section{Conclusion}
\label{sec:conclusion}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliography{refs}
\bibliographystyle{plain}

\end{document}



% Local Variables:
% ispell-local-dictionary:"american"
% End:


%  LocalWords:  affine subspaces linearized factorizations
%  LocalWords:  iteratively
